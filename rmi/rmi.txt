O que √© RMI?

Java RMI √© um mecanismo para permitir a invoca√ß√£o de m√©todos que residem em diferentes m√°quinas virtuais Java (JVM). O JVM pode estar em diferentes m√°quinas ou podem estar na mesma m√°quina. Em ambos os casos, o m√©todo pode ser executado em um endere√ßo diferente do processo de chamada. Java RMI √© um mecanismo de chamada de procedimento remoto orientada a objetos.
Aplica√ß√£o de objetos distribu√≠dos

Uma aplica√ß√£o RMI √© frequentemente composto por dois programas diferentes, um servidor e um cliente. O servidor cria objetos remotos e faz refer√™ncias a esses objetos dispon√≠veis. Em seguida, ele √© v√°lido para clientes invocarem seus m√©todos sobre os objetos.

O cliente executa refer√™ncias remotas aos objetos remotos no servidor e invoca m√©todos nesses objetos remotos.

O modelo de RMI fornece uma aplica√ß√£o de objetos distribu√≠dos para o programador. Ele √© um mecanismo de comunica√ß√£o entre o servidor e o cliente para se comunicarem e transmitirem informa√ß√µes entre si. A aplica√ß√£o de objetos distribu√≠dos tem de prover as seguintes propriedades:

    Localiza√ß√£o de objetos remotos: O sistema tem de obter refer√™ncias a objetos remotos. Isto pode ser feito de duas maneiras. Ou, usando as instala√ß√µes de nomea√ß√£o do RMI, o registro RMI, ou passando e retornando objetos remotos.
    Comunica√ß√£o com objetos remotos: O desenvolvedor n√£o tem de lidar com a comunica√ß√£o entre os objetos remotos desde que este √© tratado pelo sistema RMI.
    Carregar os bytecodes de classe dos objetos que s√£o transferidos como argumentos ou valores.

Interfaces e Classes

    Java RMI √© um sistema de linguagem individual, a programa√ß√£o de aplica√ß√£o distribu√≠da em RMI √© bastante simples. Todas as interfaces e classes para o sistema de RMI s√£o definidos no pacote java.rmi. A classe de objeto remoto implementa a interface remota, enquanto as outras classes estendem RemoteObject.

A interface remota

    Deve estender-se a interface Remote.
    Cada declara√ß√£o de m√©todo na interface remota deve incluir a exce√ß√£o RemoteException (ou uma de suas superclasses), em sua cl√°usula lan√ßada.

A classe RemoteObject

Fun√ß√µes do servidor RMI s√£o fornecidos pela classe RemoteObject e suas subclasses Remote Server, Activatable e UnicastRemoteObject. Aqui est√° uma breve descri√ß√£o de como lidar com as diferentes classes:

    RemoteObject fornece implementa√ß√µes dos m√©todos toString, equals e hashCode na classe java.lang.Object.
    As classes UnicastRemoteObject e Activatable cria objetos remotos e os exporta, ou seja, essas classes fazem os objetos remotos usados por clientes remotos.


A classe RemoteException

A classe RemoteException √© uma super-classe das exce√ß√µes que o sistema RMI joga durante uma invoca√ß√£o de m√©todo remoto. Cada m√©todo remoto que √© declarado em uma interface remota deve especificar RemoteException (ou uma de suas superclasses), em sua cl√°usula throws para garantir a robustez das aplica√ß√µes no sistema RMI.

Quando uma chamada de m√©todo remoto tiver um erro, a exce√ß√£o RemoteException √© lan√ßada. Falha de comunica√ß√£o, erros de protocolo e falha durante a triagem ou unmarshalling de par√¢metros ou valores de retorno s√£o algumas das raz√µes para o fracasso da comunica√ß√£o RMI. RemoteException √© uma exce√ß√£o que deve ser tratada pelo m√©todo chamador. O compilador confirma que o programador de ter lidado com essas exce√ß√µes.




O stub √© um objeto substituto (proxy) que existe no lado do cliente e representa o objeto remoto que est√° realmente no servidor.

üìò Fun√ß√£o:

Ele encapsula toda a l√≥gica de comunica√ß√£o entre cliente e servidor.

Quando o cliente chama um m√©todo no stub, o stub:

Empacota os par√¢metros da chamada (serializa√ß√£o);

Envia a requisi√ß√£o para o servidor (via rede);

Aguarda a resposta;

Desempacota o resultado (desserializa√ß√£o);

Retorna o valor para o cliente.

Assim, o cliente acha que est√° chamando um m√©todo local, quando na verdade est√° chamando um m√©todo remoto.

    // Obter o stub do objeto remoto registrado no RMI Registry
    Hello stub = (Hello) Naming.lookup("rmi://localhost:1099/Hello");

    // Chamada de m√©todo remoto (na verdade, feita atrav√©s do stub)
    String response = stub.sayHello();
    System.out.println("Resposta do servidor: " + response);
Aqui, stub √© o representante local do objeto remoto HelloImpl que est√° rodando no servidor.


O m√©todo rebind() √© usado no lado do servidor para registrar (ou atualizar) um objeto remoto no RMI Registry.

üìò Fun√ß√£o:

Ele associa um nome (string) a um objeto remoto, tornando-o acess√≠vel aos clientes.

Se j√° existir um objeto registrado com aquele nome, ele ser√° substitu√≠do.

√â uma alternativa ao m√©todo bind(), que lan√ßa exce√ß√£o se o nome j√° estiver em uso.

import java.rmi.*;
import java.rmi.registry.*;
import java.rmi.server.*;

public class Server {
    public static void main(String[] args) {
        try {
            // Cria o objeto remoto
            HelloImpl obj = new HelloImpl();

            // Exporta o objeto (gera o stub automaticamente)
            Hello stub = (Hello) UnicastRemoteObject.exportObject(obj, 0);

            // Obt√©m o registro RMI
            Registry registry = LocateRegistry.getRegistry();

            // Associa o stub com o nome "Hello" no registro
            registry.rebind("Hello", stub);

            System.out.println("Servidor pronto.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
üëâ Aqui, o registry.rebind("Hello", stub); registra o objeto remoto com o nome "Hello", tornando-o acess√≠vel aos clientes.


3. Quando usar extends UnicastRemoteObject
‚úÖ Caso 1 ‚Äî Usando extends UnicastRemoteObject

Exemplo tradicional:
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class CalculadoraServidor extends UnicastRemoteObject implements Calculadora {
    public CalculadoraServidor() throws RemoteException {
        super(); // Exporta automaticamente o objeto remoto
    }

    @Override
    public int soma(int x, int y) throws RemoteException {
        return x + y;
    }
}
E no main:
Registry registry = LocateRegistry.createRegistry(1099);
registry.rebind("Calculadora", new CalculadoraServidor());
System.out.println("Servidor pronto...");
üëâ Aqui, voc√™ n√£o precisa chamar exportObject(), porque a exporta√ß√£o acontece no construtor da superclasse UnicastRemoteObject.

‚úÖ Caso 2 ‚Äî Sem herdar (exportObject() manualmente)

No seu c√≥digo atual, voc√™ fez assim:
CalculadoraServidor server = new CalculadoraServidor();
Calculadora stub = (Calculadora) UnicastRemoteObject.exportObject(server, 0);
registry.rebind("Calculadora", stub);
üëâ Nesse caso:

A classe n√£o herda UnicastRemoteObject;

Ent√£o voc√™ chama manualmente o m√©todo est√°tico exportObject() para exportar o objeto e gerar o stub.

Ou seja, extends UnicastRemoteObject e UnicastRemoteObject.exportObject() fazem a mesma coisa ‚Äî apenas de formas diferentes.


